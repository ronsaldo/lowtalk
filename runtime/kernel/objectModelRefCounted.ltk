"This is the definition of a reference refCounted object model."
Namespace named: #ObjectModel members: [
    Constant named: #OopSize type: UIntPointer value: UIntPointer size.

    OopSize = 4 ifTrue: [
        Constant named: #OopTagMask type: UIntPointer value: 3.
        Constant named: #OopTagShift type: UIntPointer value: 2.

        Constant named: #OopSmallIntegerTagMask type: UIntPointer value: 1.
        Constant named: #OopSmallIntegerTagValue type: UIntPointer value: 1.
        Constant named: #OopSmallIntegerShift type: UIntPointer value: 1.

        Constant named: #OopPointerTagMask type: UIntPointer value: OopTagMask.
        Constant named: #OopPointerTagValue type: UIntPointer value: 0.

        Constant named: #OopSizeShift type: UIntPointer value: 2.
        Constant named: #OopSizeMask type: UIntPointer value: -4.

    ] ifFalse: [
        Constant named: #OopTagMask type: UIntPointer value: 7.
        Constant named: #OopTagShift type: UIntPointer value: 3.

        Constant named: #OopSmallIntegerTagMask type: UIntPointer value: 1.
        Constant named: #OopSmallIntegerTagValue type: UIntPointer value: OopTagMask.
        Constant named: #OopSmallIntegerShift type: UIntPointer value: OopTagShift.

        Constant named: #OopPointerTagMask type: UIntPointer value: OopTagMask.
        Constant named: #OopPointerTagValue type: UIntPointer value: 0.

        Constant named: #OopSizeShift type: UIntPointer value: 3.
        Constant named: #OopSizeMask type: UIntPointer value: -8.
    ].

    Constant named: #IdentityHashShift value: 4.

    Constant named: #ObjectFormatEmpty value: 0.
    Constant named: #ObjectFormatFixedSize value: 1.
    Constant named: #ObjectFormatVariableSizeNoIVars value: 2.
    Constant named: #ObjectFormatVariableSizeWithIVars value: 3.
    Constant named: #ObjectFormatWeakVariableSize value: 4.
    Constant named: #ObjectFormatWeakFixedSize value: 5.
    Constant named: #ObjectFormatImmediate value: 7.
    Constant named: #ObjectFormatIndexable64 value: 9.
    Constant named: #ObjectFormatIndexable32 value: 10.
    Constant named: #ObjectFormatIndexable16 value: 12.
    Constant named: #ObjectFormatIndexable8 value: 16.
    Constant named: #ObjectFormatMixedObject value: 24.

    Constant named: #StaticOopFlag type: UInt8 value: 1.
    Global named: #ImmediateClassTable type: (ObjectHeader pointer array: 16).

    "The object header"
    Structure named: #ObjectHeader slots: {
        #classPointer => ObjectHeader pointer.
        #refCount => UIntPointer.

        #identityHash => UInt16.
        #flags => UInt8.
        #format => UInt8.
        #slotCount => UInt32.
    }.

    Constant named: #isNonImmediateObject value: [<BooleanBit> :object<ObjectHeader pointer> |
        <cdecl>
        let oop := object reinterpretCastTo: UIntPointer.
        (oop & OopPointerTagMask) = OopPointerTagValue
    ].

    Constant named: #isSmallInteger value: [<BooleanBit> :oop<UIntPointer> |
        <cdecl>
        (oop & OopSmallIntegerTagMask) = OopSmallIntegerTagValue
    ].

    Constant named: #decodeSmallInteger value: [<IntPointer> :oop<UIntPointer> |
        <cdecl>
        (oop reinterpretCastTo: IntPointer) >> OopSmallIntegerShift
    ].

    Constant named: #encodeSmallInteger value: [<UIntPointer> :value<IntPointer> |
        <cdecl>
        (value << OopSmallIntegerShift | OopSmallIntegerTagMask) reinterpretCastTo: UIntPointer
    ].

    "Reference counting"
    Constant named: #increaseReference value: [<Void> :object<ObjectHeader pointer> |
        <cdecl>
        isNonImmediateObject #{object} ifTrue: [
            object value refCount address fetchAndAdd: 1
        ]
    ].

    Constant named: #releaseReference value: [<Void> :object<ObjectHeader pointer> |
        <cdecl>
        isNonImmediateObject #{object} ifTrue: [
            (object value refCount address fetchAndAdd: -1) = 0 ifTrue: [
                destroyObject #{object}
            ]
        ]
    ].

    Constant named: #destroyObject value: [<Void> :object<ObjectHeader pointer> |
        <cdecl>
        (object value flags & StaticOopFlag) ~= 0 ifFalse: [
            "TODO: Call the object finalizer"
            LibC free #{object}
        ]
    ].

    Constant named: #writeBarrier value: [<Void> :variable<ObjectHeader pointer pointer> :value<ObjectHeader pointer> |
        <cdecl>
        increaseReference #{value}.
        releaseReference #{variable swapValue: value}.
    ].

    Constant named: #getPointersBasicSize value: [<UIntPointer> :object<ObjectHeader pointer> |
        <cdecl>
        object value slotCount
    ].

    Constant named: #getIdentityHash value: [<UIntPointer> :object<ObjectHeader pointer> |
        <cdecl>
        object value identityHash
    ].

"
newObjectHeaderWithWeakPointers
newObjectHeaderWithWords
"

    Constant named: #newObjectHeaderWithPointers value: [<ObjectHeader> :slotCount<UInt32> |
        <cdecl>
        ObjectHeader new
            slotCount: slotCount;
            flags: StaticOopFlag;
            format: ((slotCount > 0 ifTrue: [ObjectFormatFixedSize] ifFalse: [ObjectFormatEmpty]) castTo: UInt8);
            yourself
    ].

    Constant named: #newObjectHeaderWithBytes value: [<ObjectHeader> :slotCount<UInt32> |
        <cdecl>
        ObjectHeader new
            slotCount: (slotCount + OopSize - 1) // OopSize;
            flags: StaticOopFlag;
            format: (ObjectFormatIndexable8 + ( (OopSize - slotCount) \\ OopSize) castTo: UInt8);
            yourself
    ].

    Constant named: #getBytesObjectSize value: [<UIntPointer> :object<ObjectHeader pointer> |
        <cdecl>
        (object value slotCount * OopSize) - (object value format - ObjectFormatIndexable8)
    ].

    Constant named: #getFirstFixedFieldPointer value: [<Void pointer> :object<ObjectHeader pointer> |
        <cdecl>
        (object reinterpretCastTo: UIntPointer) + ObjectHeader size reinterpretCastTo: Void pointer
    ].

    Constant named: #setObjectClass value: [<Void> :header<ObjectHeader pointer> :classPointer <ObjectHeader pointer> |
        <cdecl>
        header value classPointer: classPointer
    ].

    Constant named: #getObjectClass value: [<ObjectHeader pointer> :header<ObjectHeader pointer> |
        <cdecl>

        let oopValue := header reinterpretCastTo: UIntPointer.
        let oopTag := oopValue & OopTagMask.
        (oopTag ~= 0 or: [header == nil]) ifTrue: [
            ImmediateClassTable atOffset: oopTag
        ] ifFalse: [
            header value classPointer
        ]
    ].

    Constant named: #setIdentityHash value: [<Void> :header<ObjectHeader pointer> :newIdentityHash<UIntPointer> |
        <cdecl>
        header value identityHash: (newIdentityHash castTo: UInt16)
    ].

    Constant named: #truncateIdentityHash value: [<UIntPointer> :rawIdentityHash<UIntPointer> |
        <cdecl>
        rawIdentityHash bitAnd: 16rFFFF
    ].

    Constant named: #createFormatSpec value: [:instanceSpec<UInt32> :instanceSize<UInt32> |
        <cdecl>
        (instanceSpec << 16) | instanceSize
    ].

    Constant named: #createNamedFormatSpec value: [:type :instanceSize<UInt32> |
        <cdecl>
        <localReturn>
        type == #pointers ifTrue: [
            ^ createFormatSpec #{instanceSize == 0 ifTrue: [ ObjectFormatEmpty ] ifFalse: [ ObjectFormatFixedSize] . instanceSize }
        ].
        type == #variablePointers ifTrue: [
            ^ createFormatSpec #{instanceSize == 0 ifTrue: [ ObjectFormatVariableSizeNoIVars ] ifFalse: [ ObjectFormatVariableSizeWithIVars ] . instanceSize}
        ].
        type == #variableWeakPointers ifTrue: [
            ^ createFormatSpec #{ObjectFormatWeakVariableSize . 0 }
        ].
        type == #immediate ifTrue: [
            ^ createFormatSpec #{ObjectFormatImmediate . 0 }
        ].
        type == #words ifTrue: [
            ^ createFormatSpec #{ObjectFormatIndexable32 . 0 }
        ].
        type == #bytes ifTrue: [
            ^ createFormatSpec #{ObjectFormatIndexable8 . 0 }
        ].

        Compiler compileError: 'Unsupported object type {1}' format: {type}.
        ^ nil
    ].

    Constant named: #basicNewVariable value: [<ObjectHeader pointer> :class<ObjectHeader pointer> :formatOop<UIntPointer> :variableSizeOop<UIntPointer> |
        <cdecl>
        <localReturn>
                isSmallInteger #{formatOop} ifFalse: [
            ^ nil
        ].

        isSmallInteger #{variableSizeOop} ifFalse: [
            ^ nil
        ].

        let formatSpec := decodeSmallInteger #{formatOop}.
        let variableSize := decodeSmallInteger #{variableSizeOop}.

        let format := formatSpec >> 16.
        let fixedSize := formatSpec & 16rFFFF.

        let completeSize := fixedSize + variableSize.

        "TODO: Replace this with a lookup table"
        let displayedSlotSize<UIntPointer> := 0.
        format >= ObjectFormatIndexable64 ifTrue: [
            format >= ObjectFormatIndexable16 ifTrue: [
                format >= ObjectFormatIndexable8 ifTrue: [
                    displayedSlotSize := 1
                ] ifFalse: [
                    displayedSlotSize := 2
                ]
            ] ifFalse: [
                format >= ObjectFormatIndexable32 ifTrue: [
                    displayedSlotSize := 4
                ] ifFalse: [
                    displayedSlotSize := 8
                ]
            ]
        ] ifFalse: [
            displayedSlotSize := UIntPointer size
        ].

        "LibC printf #{c'basicNew format %d fixedSize %d variableSize %d displayedSlotSize %p \n' . format . fixedSize . variableSize . displayedSlotSize}."

        let bodySize := completeSize * displayedSlotSize.
        let instanceFormat<UInt8> := 0.
        let slotCount<UIntPointer> := 0.
        displayedSlotSize < UIntPointer size ifTrue: [
            slotCount := (bodySize + OopSize - 1) // OopSize.
            instanceFormat := format castTo: UInt8.
        ] ifFalse: [
            slotCount := bodySize // OopSize.
            instanceFormat := format castTo: UInt8
        ].

        "LibC printf #{c'slotCount %d instanceFormat: %d\n' . slotCount . instanceFormat}."

        let objectSize := ObjectHeader size + (slotCount * OopSize).
        let result := LibC malloc #{objectSize} reinterpretCastTo: ObjectHeader pointer.
        LibC memset #{result . 0 . objectSize}.

        result value
            classPointer: class;
            identityHash: ((result reinterpretCastTo: UIntPointer) >> IdentityHashShift castTo: UInt16);
            slotCount: slotCount;
            refCount: 0;
            format: instanceFormat;
            yourself.

        "LibC printf #{c'result slotCount %d -> %d instanceFormat: %d\n' . slotCount . result value slotCount . result value format}."
        ^ result
    ].

    Constant named: #basicNewFixed value: [<ObjectHeader pointer> :class<ObjectHeader pointer> :formatOop<UIntPointer> |
        <cdecl>
        <localReturn>
        ^ basicNewVariable #{class . formatOop . 1}
    ].


    Compiler objectModel
    	headerType: ObjectModel ObjectHeader;
    	writeBarrier: writeBarrier;
        newObjectHeaderWithPointers: newObjectHeaderWithPointers;
        newObjectHeaderWithBytes: newObjectHeaderWithBytes;
        setIdentityHashFunction: setIdentityHash;
        truncateIdentityHashFunction: truncateIdentityHash;

        setObjectClassFunction: [<Void> :header<ObjectHeader pointer> :classPointer <ObjectHeader pointer> |
            header value classPointer: classPointer
        ];
        getObjectClassFunction: [<ObjectHeader pointer> :header<ObjectHeader pointer> |
            header value classPointer
        ];
        yourself

]
