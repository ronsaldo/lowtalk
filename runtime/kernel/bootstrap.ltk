"
Bootstrap Smalltalk kernel.
"

let bootstrapClassHierarchy := #(
    "Core classes"
    (nil ProtoObject pointers () ())
    (ProtoObject Object pointers () ())

    (Object Behavior pointers (superclass methodDict format layout) ())
        (Behavior ClassDescription pointers (instanceVariables organization) ())
            (ClassDescription Class pointers (subclasses name classPool sharedPools environment category traitComposition localSelectors) ())
            (ClassDescription Metaclass pointers (thisClass traitComposition localSelectors) ())

    (Object UndefinedObject pointers () ())
    (Object Boolean pointers () ())
        (Object True pointers () ())
        (Object False pointers () ())

    "Magnitude"
    (Object Magnitude pointers () ())
        (Magnitude Character immediate () ())
        (Magnitude Number pointers () ())
            (Number Float pointers () ())
                (Float BoxedFloat64 words () ())
                (Float SmallFloat immediate () ())
            (Number Fraction pointers () ())
            (Number Integer pointers () ())
                    (Integer LargeInteger bytes () ())
                            (LargeInteger LargeNegativeInteger bytes () ())
                            (LargeInteger LargePositiveInteger bytes () ())
                    (Integer SmallInteger immediate () (minVal maxVal))
        (Magnitude LookupKey pointers (key) ())
            (LookupKey Association pointers (value) ())
                (Association LiteralVariable pointers () ())
                    (LiteralVariable ClassVariable pointers () ())
                    (LiteralVariable GlobalVariable pointers () ())
                    (LiteralVariable WorkspaceVariable pointers () ())
    (Object Point pointers () ())

    "Collections"
    (Object Collection pointers () ())
        (Collection HashedCollection pointers (tally array) ())
            (HashedCollection Dictionary pointers () ())
                (Dictionary IdentityDictionary pointers () ())
                    (IdentityDictionary SystemDictionary pointers () ())
                (Dictionary MethodDictionary pointers (values) ())
            (HashedCollection Set pointers () ())
                (Set IdentitySet pointers () ())
                (Set WeakSet pointers () ())
        (Collection SequenceableCollection pointers () ())
            (SequenceableCollection OrderedCollection pointers (array firstIndex lastIndex) ())
            (Collection ArrayedCollection pointers () ())
                (ArrayedCollection Array variablePointers () ())
                    (Array WeakArray variableWeakPointers () ())
                (ArrayedCollection ByteArray bytes () ())
                (ArrayedCollection String pointers () ())
                    (String ByteString bytes () ())
                    (String WideString words () ())
                    (String Symbol pointers () ())
                        (Symbol ByteSymbol bytes () ())
                        (Symbol WideSymbol words () ())

    "Context"
    (Array CompiledMethod variablePointers (entryPoint) ())

    (Object Message pointers (selector args lookupClass) ())
    (Object InstructionStream pointers (sender pc) ())
        (InstructionStream Context variablePointers (stackp method closureOrNil receiver) ())

    (Object BlockClosure variablePointers (outerContext startpc numArgs) ())
        (BlockClosure FullBlockClosure variablePointers (receiver) ())

    (Object Mutex pointers () ())
    (Object Semaphore pointers () ())

    "FFI"
   (Object ExternalAddress bytes () (wordSize))
    (Object ExternalObject pointers (handle) ())
        (ExternalObject ExternalFunction pointers (flags argTypes) ())
        (ExternalObject ExternalLibrary pointers (name) ())
        (ExternalObject ExternalStructure pointers () ())
            (ExternalStructure ExternalData pointers (type) ())

    (ByteArray Alien bytes () ())
    (Object UnsafeAlien pointers (nonPointerObject) ())
).

let superClassSlotIndex := 1.
let methodDictionarySlotIndex := 2.
let formatSlotIndex := 3.

Compiler objectModel
    superClassSlotIndex: superClassSlotIndex;
    methodDictionarySlotIndex: methodDictionarySlotIndex.

"Compute the size of the instance side"
let classInstanceSizeDictionary := Compiler newDictionary.
bootstrapClassHierarchy do: [:classDefinition |
    let baseName := classDefinition at: 1.
    let name := classDefinition at: 2.
    let type := classDefinition at: 3.
    let instanceVariables := classDefinition at: 4.
    let metaInstanceVariables := classDefinition at: 5.

    let instanceSize := instanceVariables size.
    let metaInstanceSize := metaInstanceVariables size.
    baseName ifNotNil: [
        instanceSize := instanceSize + (classInstanceSizeDictionary at: baseName).
    ].

    classInstanceSizeDictionary at: name put: instanceSize.
].

"Compute the size of the meta side"
let metaclassInstanceSizeDictionary := Compiler newDictionary.
bootstrapClassHierarchy do: [:classDefinition |
    let baseName := classDefinition at: 1.
    let name := classDefinition at: 2.
    let type := classDefinition at: 3.
    let instanceVariables := classDefinition at: 4.
    let metaInstanceVariables := classDefinition at: 5.

    let metaInstanceSize := metaInstanceVariables size.
    baseName ifNotNil: [
        metaInstanceSize := metaInstanceSize + (metaclassInstanceSizeDictionary at: baseName).
    ] ifNil: [
        metaInstanceSize := metaInstanceSize + (classInstanceSizeDictionary at: #Class).
    ].

    metaclassInstanceSizeDictionary at: name put: metaInstanceSize.
].

"Build the class objects"
let metaClassSize := classInstanceSizeDictionary at: #Metaclass.
bootstrapClassHierarchy do: [:classDefinition |
    let baseName := classDefinition at: 1.
    let name := classDefinition at: 2.
    let type := classDefinition at: 3.
    let instanceVariables := classDefinition at: 4.
    let metaInstanceVariables := classDefinition at: 5.

    let instanceSize := classInstanceSizeDictionary at: name.
    let metaInstanceSize := metaclassInstanceSizeDictionary at: name.

    "Create the meta class"
    let metaClass := Compiler objectModel newObjectWithPointers: metaClassSize.
    (Compiler objectModel registerClass: metaClass)
        type: #pointers;
        instanceVariables: metaInstanceVariables.
    Compiler objectModel
        setObject: metaClass slot: formatSlotIndex value: (ObjectModel createNamedFormatSpec #{#pointers . metaInstanceSize castTo: UInt32}).

    "Create the class"
    let class := Compiler objectModel newObjectWithPointers: metaInstanceSize.
    Compiler objectModel setObject: class class: metaClass.
    (Compiler objectModel registerClass: class)
        type: type;
        instanceVariables: instanceVariables.
    Compiler objectModel
        setObject: class slot: formatSlotIndex value: (ObjectModel createNamedFormatSpec #{type . instanceSize castTo: UInt32}).

    "Link the super classes."
    baseName ifNotNil: [
        let superClass := _GlobalNamespace at: baseName.
        Compiler objectModel
            setObject: class slot: superClassSlotIndex value: superClass.

        let superMeta := Compiler objectModel getObjectClass: superClass.
        Compiler objectModel
            setObject: metaClass slot: superClassSlotIndex value: superMeta.
    ].

    Global named: name type: _DynamicObject value: class
].

"Method dictionary definition."
let methodDictionarySize := classInstanceSizeDictionary at: #MethodDictionary.
let MethodDictionary_initialize := [ :self<MethodDictionary> |
    tally := 0.
    array := #().
    values := #().
].

let MethodDictionary_new := [
    let result := Compiler objectModel newObjectWithPointers: methodDictionarySize.
    Compiler objectModel setObject: result class: MethodDictionary.
    MethodDictionary_initialize value: result.
    result.
].

"Tricky parts on the class hierarchy."
let classHierarchyShortCirtcuit := [
    "Make 'Class' the super class of 'ProtoObject class'"
    let protoObjectMeta := Compiler objectModel getObjectClass: ProtoObject.
    Compiler objectModel setObject: protoObjectMeta slot: superClassSlotIndex value: Class.

    "Set the classes of the special literals."
    Compiler objectModel
        setObject: nil class: UndefinedObject;
        setObject: true class: True;
        setObject: false class: False.

    "Instantiate the special literals."
    Constant
        named: #nil type: _DynamicObject value: nil;
        named: #true type: _DynamicObject value: (Compiler objectModel setObject: (Compiler objectModel newObjectWithPointers: 0) class: True);
        named: #false type: _DynamicObject value: (Compiler objectModel setObject: (Compiler objectModel newObjectWithPointers: 0) class: False).

    Compiler objectModel
        trueVariable: (_GlobalNamespace variableAt: #true);
        falseVariable: (_GlobalNamespace variableAt: #false).

    "Finish this part"
    bootstrapClassHierarchy do: [:classDefinition |
        let name := classDefinition at: 2.

        "Create the method dictionaries."
        let class := _GlobalNamespace at: name.
        let classMethodDictionary := MethodDictionary_new value.

        Compiler objectModel
            setObject: classMethodDictionary class: MethodDictionary;
            setObject: class slot: methodDictionarySlotIndex value: classMethodDictionary.

        let metaClass := Compiler objectModel getObjectClass: class.
        let metaClassMethodDictionary := MethodDictionary_new value.
        Compiler objectModel
            setObject: metaClassMethodDictionary class: MethodDictionary;
            setObject: metaClass slot: methodDictionarySlotIndex value: metaClassMethodDictionary.

        "Set the metaclass class. Parallel hierarchy shortcircuiting."
        Compiler objectModel setObject: metaClass class: Metaclass.
    ]
].
classHierarchyShortCirtcuit value.

"More of the method dictionary methods."
let MethodDictionary_scanFor := [<UIntPointer> :self<MethodDictionary> :key |
    <localReturn>
    <selector: #scanFor:>
    let finish<UIntPointer> := array basicSize.
    finish == 0 ifTrue: [
        ^ 0
    ].

    let start<UIntPointer> := (key identityHash \\ finish) + 1.
    let element := nil.

    "Search from (hash mod size) to the end."
    start to: finish do: [:index<UIntPointer> |
        ((element := array basicAt: index) == nil or: [element == key])
            ifTrue: [^ index ]
    ].

    "Search from 1 to where we started."
    1 to: start-1 do: [:index<UIntPointer> |
        ((element := array basicAt: index) == nil or: [element == key])
            ifTrue: [^ index ]
    ].

    ^ 0  "No match AND no empty slot"
].

let MethodDictionary_atOrNil := [:self<MethodDictionary> :key |
    <localReturn>
    <selector: #atOrNil:>
    let index := MethodDictionary_scanFor #{self . key}.
    ^ index ~= 0 ifTrue: [values basicAt: index] ifFalse: [nil].
].

let MethodDictionary_atPutNoCheck := [:self<MethodDictionary> :key :value |
    <selector: #at:putNoCheck:>
    let index := MethodDictionary_scanFor #{self . key}.
    array basicAt: index put: key.
    values basicAt: index put: value.
    tally := tally + 1.
].

let MethodDictionary_grow := [ :self<MethodDictionary> |
    <selector: #grow>

    let oldKeys := array.
    let oldValues := values.
    let oldSize := array basicSize.
    let newSize := oldSize * 2.
    newSize < 8 ifTrue: [ newSize := 8 ].

    array := Array basicNew: newSize.
    values := Array basicNew: newSize.

    tally := 0.
    1 to: oldSize do: [:i |
        let key := oldKeys basicAt: i.
        let value := oldValues basicAt: i.
        key ifNotNil: [
            MethodDictionary_atPutNoCheck #{self. key. value}.
        ]
    ].
].

let MethodDictionary_atPut := [:self<MethodDictionary> :key :value |
    <selector: #at:put:>

    let index := MethodDictionary_scanFor #{self . key}.
    index = 0 ifTrue: [
        MethodDictionary_grow #{self}.
        index := MethodDictionary_scanFor #{self . key}
    ].

    (array basicAt: index) ifNil: [
        tally := tally + 1.
        tally >= (array basicSize * 3 // 4) ifTrue: [
            MethodDictionary_grow #{self}.
            index := MethodDictionary_scanFor #{self . key}
        ]
    ].

    array basicAt: index put: key.
    values basicAt: index put: value.
].
"Behavior methods"
let Behavior_superclass := [ <Behavior> :self<Behavior> |
    <selector: #superclass>
    superclass castTo: Behavior
].

let Behavior_methodDict := [ <MethodDictionary> :self<Behavior> |
    <selector: #methodDict>
    methodDict castTo: MethodDictionary
].

let Behavior_lookupSelector := [ :self<Behavior> :selector |
    <selector: #lookupSelector:>
    <localReturn>
    let position := self.
    [position == nil] whileFalse: [
        let result := MethodDictionary_atOrNil #{ Behavior_methodDict #{position} .  selector }.
        result ifNotNil: [^ result].
        position := Behavior_superclass #{position} castTo: Behavior
    ].

    ^ nil
].

Compiler objectModel lookupSelectorFunction: Behavior_lookupSelector.

"Install the method to access the methodDictionary in Behavior"
[ :self<Behavior> |
    MethodDictionary_atPut value: methodDict value: #methodDict value: Behavior_methodDict
] value: Behavior.

"Install the method for inserting entries into a method dictionary into MethodDictionary"
MethodDictionary_atPut value: MethodDictionary methodDict value: #at:put: value: MethodDictionary_atPut.

"Insert the bootstraping methods in their method dictionary"
Behavior methodDict
    at: #superclass put: Behavior_superclass;
    at: #lookupSelector put: Behavior_lookupSelector.

MethodDictionary methodDict
    at: #atOrNil: put: MethodDictionary_atOrNil;
    at: #at:putNoCheck: put: MethodDictionary_atPutNoCheck;
    at: #grow put: MethodDictionary_grow.

CompiledMethod methodDict
    at: #entryPoint put: [:self<CompiledMethod> | entryPoint];
    at: #entryPoint: put: [:self<CompiledMethod> :newEntryPoint | entryPoint := newEntryPoint. self].

"Some functions related to the object model."
Compiler objectModel
    convertArrayFunction: [:array |
        let result := Array basicNew: array size.
        1 to: array size do: [:i | result basicAt: i put: (array basicAt: i)].
        Compiler objectModel setObject: result identityHash: array identityHash.
        result
    ];
    convertByteSymbolFunction: [:symbol |
        let result := ByteSymbol basicNew: symbol size.
        1 to: symbol size do: [:i | result basicAt: i put: (symbol basicAt: i)].
        Compiler objectModel setObject: result identityHash: symbol identityHash.
        result
    ];
    convertByteStringFunction: [:string |
        let result := ByteString basicNew: string size.
        1 to: string size do: [:i | result basicAt: i put: (string basicAt: i)].
        Compiler objectModel setObject: result identityHash: string identityHash.
        result
    ];
    convertMethodContextMetadataFunction: [:entryPoint :literals |
        let result := CompiledMethod basicNew: literals size.
        result entryPoint: entryPoint.
        1 to: literals size do: [:i | result basicAt: i put: (literals at: i)].
        result
    ];
    yourself.

"A method for adding methods"
ClassDescription methodDict at: #category:methods: put: [:self<ClassDescription> :categoryName :methods |
    <selector: #category:methods:>
    <localReturn>
    methods do: [:method |
        let compiledMethod := method compiledMethodForReceiverType: self.
        methodDict at: compiledMethod selector put: compiledMethod
    ]
].

"Register some special classes"
let oopSize := UIntPointer size.

oopSize = 4 ifTrue: [
    ObjectModel ImmediateClassTable
        atOffset: 0 put: UndefinedObject;
        atOffset: 1 put: SmallInteger.
] ifFalse: [
    ObjectModel ImmediateClassTable
        atOffset: 0 put: UndefinedObject;
        atOffset: 1 put: SmallInteger.
].

"Now we can implement the object creation primitives."
Behavior category: 'instance creation' methods: {
:[basicNew
    let result := ObjectModel basicNewFixed #{self reinterpretCastTo: ObjectModel ObjectHeader pointer . format reinterpretCastTo: UIntPointer}.
    ^ result reinterpretCastTo: _DynamicObject
].

:[basicNew: size
    let result := ObjectModel basicNewVariable #{self reinterpretCastTo: ObjectModel ObjectHeader pointer . format reinterpretCastTo: UIntPointer . size reinterpretCastTo: UIntPointer}.
    ^ result reinterpretCastTo: _DynamicObject
].

:[new
    ^ self basicNew initialize; yourself
].

:[new: size
    ^ (self basicNew: size) initialize; yourself
].

}.

ProtoObject category: 'initialization' methods: {
:[initialize
    "By default do nothing"
]
}.

ProtoObject category: 'accessing' methods: {
:[at: index
    ^ self basicAt: index
].

:[at: index put: value
    ^ self basicAt: index put: value
].

:[size
    ^ self basicSize
].

:[basicAt: index
    let indexValue := index castTo: UIntPointer.
    let size := ObjectModel getObjectIndexableSize #{self reinterpretCastTo: ObjectModel ObjectHeader pointer}.
    (indexValue < 1 or: [indexValue > size]) ifTrue: [
        self errorSubscriptBounds: index
    ].

    let result := ObjectModel uncheckedIndexableBasicAt #{self reinterpretCastTo: ObjectModel ObjectHeader pointer . indexValue}.
    ^ result reinterpretCastTo: _DynamicObject
].

:[basicAt: index put: value
    let indexValue := index castTo: UIntPointer.
    let size := ObjectModel getObjectIndexableSize #{self reinterpretCastTo: ObjectModel ObjectHeader pointer}.
    (indexValue < 1 or: [indexValue > size]) ifTrue: [
        self errorSubscriptBounds: index
    ].

    ObjectModel uncheckedIndexableBasicAtPut #{self reinterpretCastTo: ObjectModel ObjectHeader pointer . indexValue . value reinterpretCastTo: ObjectModel ObjectHeader pointer}.
    ^ value
].

:[basicSize
    ^ ObjectModel getObjectIndexableSize #{self reinterpretCastTo: ObjectModel ObjectHeader pointer}
].

:[yourself
    ^ self
].

}.

ProtoObject category: 'errors' methods: {
:[error: aMessage
    LibC printf #{c'Fatal error\n'}.
    LibC abort #{}.
].

:[errorSubscriptBounds: index
    self error: 'Index ' , index asString , 'is out of bounds.'
].
}.

ProtoObject category: 'reflective operations' methods: {
:[doesNotUnderstand: aMessage
    self error: 'Received an unhandled doesNotUnderstand.\n'
].

}.

Class category: 'accessing' methods: {
:[name
    ^ name
].

:[name: aName
    name := aName
].

:[subclasses
    ^ subclasses ifNil: [ #() ] ifNotNil: [ subclasses copy ]
].

:[subclasses: aCollectionOfSubclasses
    subclasses := aCollectionOfSubclasses
].

:[addSubclass: aSubClass
    self subclasses: (self subclasses copyWith: aSubClass)
].

}.

Metaclass category: 'accessing' methods: {
:[name
    ^ thisClass name , ' class'
].

:[thisClass
    ^ thisClass
].

:[thisClass: aClass
    thisClass := aClass
].

}.

"Finish the initialization of the class hierarchy"
let classHierarchyInitializationFinish := [
    "Finish this part"
    bootstrapClassHierarchy do: [:classDefinition |
        let name := classDefinition at: 2.
        let class := _GlobalNamespace at: name.
        let metaClass := class class.

        "Set the class name"
        class name: name.

        "Set the metaClass thisClass"
        metaClass thisClass: class.

        "Add the class to its super class"
        class superclass ifNotNil: [:superClass |
            superClass addSubclass: class
        ].
    ]
].
classHierarchyInitializationFinish value.
